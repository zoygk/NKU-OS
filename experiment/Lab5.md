# Lab5：用户程序

## 实验目的

- 了解第一个用户进程创建过程
- 了解系统调用框架的实现机制
- 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理

## 练习0：填写已有实验

> 本实验依赖实验2/3/4。请把你做的实验2/3/4的代码填入本实验中代码中有“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验2/3/4的代码进行进一步改进。

## 练习1: 加载应用程序并执行（需要编码）

> do_execv函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。
>
> 请在实验报告中简要说明你的设计实现过程。
>
> - 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

### 代码

```c
    /* LAB5:EXERCISE1 YOUR CODE
     * should set tf->gpr.sp, tf->epc, tf->status
     */
    tf->gpr.sp = USTACKTOP;
    tf->epc = elf->e_entry;
    tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);
```

### `load_icode`函数整体解析

`load_icode` 函数是操作系统中加载一个 ELF 格式二进制程序的函数。

- **检查当前进程的内存管理结构**

  - 如果当前进程已经有了内存管理结构 (`mm`)，说明该进程不允许被重新加载二进制程序，因此调用 `panic` 来报告错误。

- **创建新的内存管理结构**

  - 调用 `mm_create()` 创建一个新的内存管理结构（`mm`），用于管理当前进程的虚拟内存空间。
  - 如果内存不足或分配失败，跳转到错误处理部分。

- **设置页目录**

  - 调用 `setup_pgdir()` 创建一个新的页目录（PDT）并为当前进程配置。

- **加载 ELF 文件的程序头**

  - 通过解析 ELF 格式的头文件，读取程序头（`ph`），并检查 ELF 魔术数来验证文件格式的有效性。

- **加载各个段**

  - 遍历 ELF 文件中的每个程序段，根据程序头中的信息决定如何映射到进程的虚拟内存中。
  - 对于可执行的、写入的和读写的段，调用 `mm_map()` 为这些段分配虚拟内存并将它们映射到进程的内存空间中。
  - 如果段有实际数据（如 `.text`、`.data`），就将它们从 ELF 文件复制到分配的内存中。如果段是 BSS 段（未初始化的全局变量），则将其内存清零。

- **为用户栈分配内存**

  - 为用户栈分配足够的内存空间，并映射到进程的虚拟地址空间中。

- **设置当前进程的内存管理结构**

  - 将进程的内存管理结构（`mm`）和 CR3 寄存器指向新的页目录。

- **设置进程的 Trapframe**

  - `trapframe` 用于保存进程从内核切换到用户态时的寄存器状态。设置其中的栈指针、入口地址和状态寄存器，确保进程能够正确从内核返回到用户空间。

### 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过

流程如下：

1. 在`init_main`中通过`kernel_thread`调用`do_fork`创建并唤醒线程
2. 执行函数`user_main`，这时该线程状态已经为`PROC_RUNNABLE`，表明该线程开始运行
3. 在`user_main`中调用`kernel_execve`
4. 在`kernel_execve`中执行`ebreak`，发生断点异常跳转到`CAUSE_BREAKPOINT`
5. 在`CAUSE_BREAKPOINT`处调用`syscall`，执行`sys_exec`，调用`do_execve`
6. 在`do_execve`中调用`load_icode`，加载文件
7. 加载完毕后返回，直到`__alltraps`的末尾，接着执行`__trapret`后的内容，到`sret`，表示退出S态，回到用户态执行，这时开始执行用户的应用程序

## 练习2: 父进程复制自己的内存空间给子进程（需要编码）

> 创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。
>
> 请在实验报告中简要说明你的设计实现过程。
>
> 如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。
>
> - Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。

### 代码

```c
            /* LAB5:EXERCISE2 YOUR CODE
             * (1) find src_kvaddr: the kernel virtual address of page
             * (2) find dst_kvaddr: the kernel virtual address of npage
             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
             * (4) build the map of phy addr of  nage with the linear addr start
             */
            uintptr_t* src = page2kva(page);
            uintptr_t* dst = page2kva(npage);
            memcpy(dst, src, PGSIZE);
            ret = page_insert(to, npage, start, perm);
```

### `copy_range` 函数解释

这个函数的整体作用是将源进程的虚拟地址空间中的一段内存（按照页面对齐）复制到目标进程的虚拟地址空间中。

- **输入参数检查：**
  - 函数首先确认了 `start` 和 `end` 是页面对齐的地址（即它们的值应该是页大小 `PGSIZE` 的倍数）。如果不是，断言会失败。
  - `USER_ACCESS(start, end)` 确保 `start` 和 `end` 范围内的地址对用户进程是可访问的。

- **循环复制内存：**
  - 函数通过一个 `do-while` 循环按页复制内存，直到 `start` 大于或等于 `end`。

- **处理每一页：**
  - 对于每个页面，首先检查源进程的页表项是否有效。`get_pte(from, start, 0)` 函数用于获取源进程在 `start` 地址处的页表项。如果找不到页表项，则将 `start` 向上对齐到下一个页的起始位置，并继续。
  - 如果源页表项存在且有效，函数会在目标进程的页表中查找一个空白页表项，并分配物理页面。

- **分配新页面并复制数据：**
  - 函数为目标进程分配一个新的页面，并获取源进程对应页面的内核虚拟地址（`page2kva(page)`），然后将源页面的内容复制到目标页面。
  - 复制数据后，函数使用 `page_insert` 将新页面映射到目标进程的地址空间。

- **重复直到完成复制：**
  - 循环继续，直到复制整个地址范围。

- **返回结果：**
  - 如果成功复制所有页面，函数返回 `0`。

### 如何设计实现Copy on Write机制？给出概要设计

Copy-on-write（简称COW）的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。

### 实验结果

## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

> 请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：
>
> - 请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
> - 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）  
>
> 执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-1.0.1）

### 分析fork/exec/wait/exit的执行流程

### 用户态进程的执行状态生命周期图

## 扩展练习 Challenge1

> 实现 Copy on Write （COW）机制
>
> 给出实现源码,测试用例和设计报告（包括在cow情况下的各种状态转换（类似有限状态自动机）的说明）。
>
> 这个扩展练习涉及到本实验和上一个实验“虚拟内存管理”。在ucore操作系统中，当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。请在ucore中实现这样的COW机制。
>
> 由于COW实现比较复杂，容易引入bug，请参考 <https://dirtycow.ninja/> 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。
>
> 这是一个big challenge.

## 扩展练习 Challenge2

说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？
